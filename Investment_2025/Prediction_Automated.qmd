---
title: "Prediction_Automated"
author: "Lajos Galambos"
format: md
---

# Description

In a [previous file](https://github.com/galamboslajos/Finance-Working-Files/blob/main/Investment_2025/Index_Modelling.md), we tried out multiple methods to come up with precise prediction results for Nasdaq 100 daily returns (direction: +/-). This time we want to implement those results form the most accurate Logistic Regression model to a more automated process. We will work with code that feeds the model with new data and returns the predictions.

```{r}
#| echo: false
#| message: false
#| warning: false
# ================================
# Logistic Regression Model with Sanity Checks
# ================================

library(quantmod)
library(dplyr)
library(zoo)

nasdaq_data <- getSymbols("^IXIC", src = "yahoo",
                          from = Sys.Date() - (365 * 10),
                          to = Sys.Date(), 
                          auto.assign = FALSE)

nasdaq_returns <- dailyReturn(Cl(nasdaq_data), type = "log")

full_data <- data.frame(
  date = index(nasdaq_returns),
  return = as.numeric(nasdaq_returns)
) %>%
  mutate(
    r_lag1 = lag(return, 1),
    r_lag2 = lag(return, 2),
    r_lag3 = lag(return, 3),
    abs_r_lag1 = abs(lag(return, 1)),
    roll_mean5 = rollapply(return, width = 5, FUN = mean, align = "right", fill = NA),
    roll_sd5 = rollapply(return, width = 5, FUN = sd, align = "right", fill = NA),
    target = ifelse(return > 0, 1, 0)  # Binary target: 1 if return > 0, else 0
  ) %>%
  na.omit()

cat("\n### Sample of Feature Set:\n")
print(knitr::kable(head(full_data, 5), format = "markdown"))

split_date <- as.Date("2023-01-01")  # split date
train_data <- full_data %>% filter(date < split_date)
test_data <- full_data %>% filter(date >= split_date)

X_train <- train_data %>% select(r_lag1, r_lag2, r_lag3, abs_r_lag1, roll_mean5, roll_sd5)
y_train <- train_data$target
model_data <- cbind(X_train, target = y_train)

logistic_model <- glm(target ~ ., data = model_data, family = binomial(link = "logit"))

cat("\n### Logistic Regression Model Summary:\n")
summary_output <- capture.output(summary(logistic_model))
cat(paste("```\n", paste(summary_output, collapse = "\n"), "\n```", sep = ""))
```
Coefficients:

r_lag1, r_lag2, and r_lag3 have highly significant negative coefficients (p-values < 2e-16), indicating that lagged returns are strong predictors of the target variable.
roll_mean5 has a highly significant positive coefficient, suggesting that the 5-day rolling mean is also a strong predictor.
abs_r_lag1 and roll_sd5 are not statistically significant (p-values > 0.05), meaning they may not contribute much to the model.

Variables with *** are highly significant, meaning they strongly influence the target variable.

```{r}
#| echo: false
#| message: false
#| warning: false
# ================================
# Model Evaluation: Accuracy, Confusion Matrix, ROC Curve, and Metrics
# ================================

# Required libraries
#install.packages("caret")
# install.packages("pROC")
library(caret)  
library(pROC)   
library(ggplot2) 

train_data$predicted_prob <- predict(logistic_model, newdata = X_train, type = "response")
train_data$predicted_class <- ifelse(train_data$predicted_prob > 0.5, 1, 0)

X_test <- test_data %>% select(r_lag1, r_lag2, r_lag3, abs_r_lag1, roll_mean5, roll_sd5)
test_data$predicted_prob <- predict(logistic_model, newdata = X_test, type = "response")
test_data$predicted_class <- ifelse(test_data$predicted_prob > 0.5, 1, 0)

cat("\n### Confusion Matrix (Training Data):\n")
conf_matrix_train <- confusionMatrix(
  factor(train_data$predicted_class),
  factor(train_data$target),
  positive = "1"
)
print(knitr::kable(conf_matrix_train$table, format = "markdown"))

cat("\n### Accuracy (Training Data):\n")
print(conf_matrix_train$overall["Accuracy"])

cat("\n### Confusion Matrix (Testing Data):\n")
conf_matrix_test <- confusionMatrix(
  factor(test_data$predicted_class),
  factor(test_data$target),
  positive = "1"
)
print(knitr::kable(conf_matrix_test$table, format = "markdown"))

cat("\n### Accuracy (Testing Data):\n")
print(conf_matrix_test$overall["Accuracy"])

roc_curve_train <- roc(train_data$target, train_data$predicted_prob)
roc_curve_test <- roc(test_data$target, test_data$predicted_prob)

cat("\n### AUC (Training Data):\n")
print(auc(roc_curve_train))

cat("\n### AUC (Testing Data):\n")
print(auc(roc_curve_test))

plot(roc_curve_train, col = "blue", main = "ROC Curve (Training vs Testing)", lwd = 2)
lines(roc_curve_test, col = "green", lwd = 2)
abline(a = 0, b = 1, lty = 2, col = "red")  # Diagonal line for random guessing
legend("bottomright", legend = c("Training", "Testing"), col = c("blue", "green"), lwd = 2)

rmse_train <- sqrt(mean((train_data$predicted_prob - train_data$target)^2))
cat("\n### Root Mean Squared Error (RMSE) - Training Data:\n")
print(rmse_train)

rmse_test <- sqrt(mean((test_data$predicted_prob - test_data$target)^2))
cat("\n### Root Mean Squared Error (RMSE) - Testing Data:\n")
print(rmse_test)

cat("\n### Akaike Information Criterion (AIC):\n")
print(AIC(logistic_model))


coefficients <- summary(logistic_model)$coefficients
feature_importance <- data.frame(
  Feature = rownames(coefficients)[-1],  
  Importance = abs(coefficients[-1, "Estimate"])  
)

cat("\n### Feature Importance:\n")
ggplot(feature_importance, aes(x = reorder(Feature, Importance), y = Importance)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  labs(title = "Feature Importance", x = "Features", y = "Importance") +
  theme_minimal()
```

```{r}
#| echo: false
#| message: false
#| warning: false
# ================================
# Daily NASDAQ Trading Suggestion (with recent data + model sanity check)
# ================================

library(quantmod)
library(dplyr)
library(zoo)
library(knitr)

nasdaq_data <- getSymbols("^IXIC", src = "yahoo",
                          from = Sys.Date() - 365*10,
                          to = Sys.Date(),
                          auto.assign = FALSE)

nasdaq_returns <- dailyReturn(Cl(nasdaq_data), type = "log")
returns_df <- data.frame(
  date = index(nasdaq_returns),
  return = as.numeric(nasdaq_returns)
)

full_data <- returns_df %>%
  mutate(
    r_lag1 = lag(return, 1),
    r_lag2 = lag(return, 2),
    r_lag3 = lag(return, 3),
    abs_r_lag1 = abs(lag(return, 1)),
    roll_mean5 = rollapply(return, 5, mean, align = "right", fill = NA),
    roll_sd5 = rollapply(return, 5, sd, align = "right", fill = NA),
    target = ifelse(return > 0, 1, 0)
  ) %>%
  na.omit()

X_train <- full_data %>% select(r_lag1, r_lag2, r_lag3, abs_r_lag1, roll_mean5, roll_sd5)
y_train <- full_data$target
logistic_model <- glm(y_train ~ ., data = X_train, family = binomial(link = "logit"))

recent_returns <- tail(returns_df, 5)

r_lag1 <- recent_returns$return[5]  # last return
r_lag2 <- recent_returns$return[4]
r_lag3 <- recent_returns$return[3]
abs_r_lag1 <- abs(r_lag1)
roll_mean5 <- mean(recent_returns$return)
roll_sd5 <- sd(recent_returns$return)

today_features <- data.frame(
  r_lag1 = r_lag1,
  r_lag2 = r_lag2,
  r_lag3 = r_lag3,
  abs_r_lag1 = abs_r_lag1,
  roll_mean5 = roll_mean5,
  roll_sd5 = roll_sd5
)

prob_up <- predict(logistic_model, newdata = today_features, type = "response")
decision <- ifelse(prob_up > 0.5, 1, 0)

cat("### Trading Suggestion for Today:\n")
cat(sprintf("- Date: %s\n", Sys.Date()))
cat(sprintf("- Probability market goes UP: %.2f%%\n", prob_up * 100))
cat(sprintf("- Suggested action: **%s**\n\n", ifelse(decision == 1, "BUY NASDAQ", "STAY IN CASH")))

cat("### Features Used for Today’s Prediction:\n")
print(kable(today_features, format = "markdown"))

cat("\n### Last 5 NASDAQ Closing Prices:\n")
closing_prices <- Cl(nasdaq_data)
print(kable(
  data.frame(Date = index(tail(closing_prices, 5)),
             Close = round(as.numeric(tail(closing_prices, 5)), 2)),
  format = "markdown"))

yesterday_return <- recent_returns$return[5]
actual_movement <- ifelse(yesterday_return > 0, 1, 0)

cat("\n### Model Sanity Check (Last Trading Day):\n")
cat(sprintf("- Return on %s was: %.4f → Market actually went %s\n",
            recent_returns$date[5],
            yesterday_return,
            ifelse(actual_movement == 1, "UP", "DOWN")))
cat(sprintf("- Model suggests **%s** today based on that.\n\n",
            ifelse(decision == 1, "BUY (1)", "STAY IN CASH (0)")))
```
## Backtested Strategy in the test set

```{r}
#| echo: false
#| message: false
#| warning: false
library(dplyr)
library(lubridate)

# Ensure date is in Date format
test_data <- test_data %>%
  mutate(date = as.Date(date),
         year = year(date))

# Identify trade entry points: when predicted_class switches from 0 to 1
test_data <- test_data %>%
  mutate(prev_signal = lag(predicted_class, default = 0),
         trade_entry = ifelse(predicted_class == 1 & prev_signal == 0, 1, 0))

# Count number of trades per year
trades_per_year <- test_data %>%
  group_by(year) %>%
  summarise(number_of_trades = sum(trade_entry))

# View results
print(trades_per_year)

```


```{r}
#| echo: false
#| message: false
#| warning: false

library(dplyr)
library(ggplot2)

test_data <- test_data %>%
  mutate(
    strategy_return = ifelse(predicted_class == 1, return, 0),
    cumulative_strategy_return = cumprod(1 + strategy_return),
    cumulative_market_return = cumprod(1 + return),
    perfect_return = ifelse(target == 1, return, 0),
    cumulative_perfect_return = cumprod(1 + perfect_return)
  )

ggplot(test_data, aes(x = as.Date(date))) +
  geom_line(aes(y = cumulative_strategy_return, color = "Strategy")) +
  geom_line(aes(y = cumulative_market_return, color = "Market (Buy & Hold)")) +
  geom_line(aes(y = cumulative_perfect_return, color = "Perfect Foresight")) +
  labs(
    title = "Cumulative Returns: Strategy vs Market vs Perfect Foresight",
    x = "Date",
    y = "Cumulative Return",
    color = "Legend"
  ) +
  theme_minimal()
```

